Static staticMaxFlow (Graph g, int source, int sink, propEdge<int> residual_capacity, propNode<int> excess) {

  propNode<int> height;
  g.attachNodeProperty (height = 0) ;
  source.height = g.num_nodes();

	forall(v in g.nodes()){
		for(dst in g.neighbors(v)){
			edge e = g.get_edge(v,dst);
			e.residual_capacity = e.weight;
		}
	}
	
	forall(v in g.neighbors(source)){
		edge forward_edge = g.get_edge(source, v) ;
		edge backward_edge = g.get_edge(v, source) ;
		int d = forward_edge.residual_capacity;
		v.excess += d;
		source.excess -=d;
		forward_edge.residual_capacity -= d;
		backward_edge.residual_capacity += d;
	}
    
	bool flag=true;

	do{
		flag = false;
        forall (v in g.nodes().filter(v.excess>0 && v!=source && v!=sink )) {
			flag = true;
			int hh = INT_MAX;
			int v_0 = -1;
			for(vv in g.neighbors(v)) {
				edge e = g.get_edge(v,vv);
				int xxx=e.residual_capacity;
				if(vv.height<hh && xxx >0){
					v_0=vv;
					hh=vv.height;
				}
			}

			if(v.height>hh && v_0!=-1){
        	    edge forward_edge = g.get_edge (v, v_0) ;
        	    edge backward_edge = g.get_edge (v_0, v) ;
				int fec = forward_edge.residual_capacity;
				int d=fec;
				if(v.excess<fec){
					d=v.excess;
				}
				v.excess -= d ;
        	    v_0.excess += d ;
				forward_edge.residual_capacity -= d ;
        	    backward_edge.residual_capacity += d ;
			}
			else if(lv!=-1){
				v.height = hh + 1;
			}
        }
    }while(flag);    

}


Incremental(Graph g, int source, int sink,propNode<int> excess,propEdge<int> residual_capacity) {
  propNode<int> height;
  g,attachNodeProperty(height = 0);
  source.height = g.num_nodes();
    
	bool flag=true;

	do{
		flag = false;
      forall (v in g.nodes().filter(v.excess>0 && v!=source && v!=sink )) {
			  flag = true;
			  int hh = INT_MAX;
			  int v_0 = -1;
			  for(vv in g.neighbors(v)) {
			  	edge e = g.get_edge(v,vv);
			  	int xxx=e.residual_capacity;
			  	if(vv.height<hh && xxx >0){
			  		v_0=vv;
			  		hh=vv.height;
			  	}
			  }

			  if(v.height>hh && v_0!=-1){
          	    edge forward_edge = g.get_edge (v, v_0) ;
          	    edge backward_edge = g.get_edge (v_0, v) ;
			  	int fec = forward_edge.residual_capacity;
			  	int d=fec;
			  	if(v.excess<fec){
			  		d=v.excess;
			  	}
			  	v.excess -= d ;
          	    v_0.excess += d ;
			  	forward_edge.residual_capacity -= d ;
          	    backward_edge.residual_capacity += d ;
			  }
			  else if(lv!=-1){
			  	v.height = hh + 1;
			  }
      }
    }while(flag);   
}

Decremental(Graph g, int source, int sink,propNode<int> excess,propEdge<int> residual_capacity) {
  
  propNode<int> height2;
  g,attachNodeProperty(height2 = 0);
  sink.height2 = g.num_nodes();

  forall(v in g.neighbors(sink)){
		edge backward_edge = g.get_edge(v, source) ;
		int d = backward_edge.residual_capacity;
		sink.excess += d;
		v.excess -=d;
		forward_edge.residual_capacity -= d;
		backward_edge.residual_capacity += d;
	}
    
	bool flag=true;

	do{
		  flag = false;
      forall (v in g.nodes().filter(v.excess<0 && v!=source && v!=sink )) {
			  flag = true;
			  int hh = INT_MAX;
			  int v_0 = -1;
			  for(vv in g.neighbors(v)) {
			  	edge e = g.get_edge(vv,v);
			  	int xxx=e.residual_capacity;
			  	if(vv.height2<hh && xxx >0){
			  		v_0=vv;
			  		hh=vv.height2;
			  	}
			  }

			  if(v.height>hh && v_0!=-1){
          edge outward_edge = g.get_edge (v, v_0) ;
          edge inward_edge = g.get_edge (v_0, v) ;
        
			  	int d = inward_edge.residual_capacity;
			  	if((-v.excess)<fec){
			  		d=-v.excess;
			  	}
			  	v.excess += d ;
          v_0.excess -= d ;
			  	inward_edge.residual_capacity -= d ;
          outward_edge.residual_capacity += d ;
			  }
			  else if(v_0!=-1){
			  	v.height2 = hh + 1;
			  }
          
      }
    }while(flag);    
}

Dynamic DynSSSP(Graph g, int source,int sink, updates<g> updateBatch, int batchSize, int src) {
  propNode<int> excess;
  g.attachNodeProperty(excess = 0);
  staticMaxFlow( g,residual_capacity,excess);
  Batch(updateBatch:batchSize) {
    OnDelete(u in updateBatch.currentBatch()): { 
      int src = u.source;
      int dest = u.destination;
      int new_capacity = u.weight;
      edge backward_edge = g.get_edge(dest,src);
      edge forward_edge = g.get_edge(src,dest);
      if(backward_edge.residual_capacity>new_capacity){
        backward_edge.residual_capacity = new_capacity;
      }
      forward_edge.residual_capacity = new_capacity - backward_edge.residual_capacity;
      forward_edge.weight = new_capacity;
    }
    OnAdd(u in updateBatch.currentBatch()):{
      int src = u.source;
      int dest = u.destination;
      int new_capacity = u.weight;
      edge forward_edge = g.get_edge(src,dest);
      forward_edge.residual_capacity = forward_edge.residual_capacity + new_capacity - forward_edge.weight;
      forward_edge.weight = new_capacity;
    }                  
    forall(v in g.nodes()){
      for(nbr in g.get_neighbors(v)){
        edge e = g.get_edge(v,nbr);
        if(e.weight>0){
          v.excess+=e.weight-e.residual_capacity;
        } else {
          v.excess-=e.residual_capacity;
        }
      }
    }
    Decremental(g,source,sink,excess,residual_capacity);
    Incremental(g,source,sink,excess,residual_capacity);
  }
}