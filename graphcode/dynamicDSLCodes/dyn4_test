Static staticMaxFlow (Graph g, int source2, int sink2, propEdge<int> residual_capacity,propEdge<int> rev_residual_capacity,propEdge<int> reverse_edge, propNode<int> excess,int cycle) {
    propNode<int> height;
    g.attachNodeProperty (height = 0) ;
    source2.height = g.num_nodes();

    g.attachNodeProperty(excess=0);
	forall(v in g.nodes()){
		for(dst in g.neighbors(v)){
			edge e1 = g.get_edge(v,dst);
			e1.residual_capacity = e1.weight;
			e1.rev_residual_capacity = 0;
		}
		for(src in g.nodes_to(v)){
			edge rev = g.get_edge(src,v);
			for(vv in g.neighbors(src)){
				edge e = g.get_edge(src,vv);
				if(vv==v){
					rev.reverse_edge = e;
				}
			}
		}
	}
	    
	forall (v in g.nodes().filter(v==source2)) {
      for(vv in g.neighbors(v)){
			  edge forward_edge = g.get_edge(v, vv) ;
			  int d = forward_edge.residual_capacity;
			  vv.excess += d;
			  v.excess-=d;
			  forward_edge.residual_capacity -= d;
			  forward_edge.rev_residual_capacity += d;
		  }
    }

	bool flag1=true;
	int kernel = 1000;
	do{
		flag1 = false;
	
        forall (v in g.nodes().filter(v.excess>0 && v!=source2 && v!=sink2 )) {
			flag1 = true;
			do {

				if(v.excess>0){
					
			int hh = INT_MAX;
			int v_0 = -1;
			int forward_edge = -1;
			int backward_edge = -1;
			for(vv in g.neighbors(v)) {
				edge e = g.get_edge(v,vv);
				int xxx=e.residual_capacity;
				if(vv.height<hh && xxx >0){
					v_0=vv;
					hh=vv.height;
					forward_edge = e;
				}
			}
			for(vv in g.nodes_to(v)) {
				edge rev = g.get_edge(vv,v);
				edge e = rev.reverse_edge;
				int xxx=e.rev_residual_capacity;
				if(vv.height<hh && xxx >0){
					v_0=vv;
					hh=vv.height;
					backward_edge = e;
					forward_edge = -1;
				}
			}

			if(v.height>hh && v_0!=-1){
				if(forward_edge!=-1){
					int fec = forward_edge.residual_capacity;
					int d=fec;
					if(v.excess<fec){
						d=v.excess;
					}
					v.excess -= d ;
        	    	v_0.excess += d ;
					forward_edge.residual_capacity -= d ;
        	    	forward_edge.rev_residual_capacity += d ;
				} else {
					int fec = backward_edge.rev_residual_capacity;
					int d=fec;
					if(v.excess<fec){
						d=v.excess;
					}
					v.excess -= d ;
        	    	v_0.excess += d ;
					backward_edge.rev_residual_capacity -= d ;
        	    	backward_edge.residual_capacity += d ;
				}

			}
			else if(v_0!=-1){
				v.height = hh + 1;
			}
				}




				cycle = cycle - 1;
			} while(cycle>0);
			
        }
    }while(flag1); 
}
Incremental(Graph g, int source0, int sink0, propEdge<int> residual_capacity,propEdge<int> rev_residual_capacity,propEdge<int> reverse_edge,propNode<int>excess, int cycle) {
      propNode<int> height;
    g.attachNodeProperty (height = 0) ;
    source0.height = g.num_nodes(); 

    forall (v in g.nodes().filter(v==source0)) {
      for(vv in g.neighbors(v)){
			  edge forward_edge = g.get_edge(v, vv) ;
			  int d = forward_edge.residual_capacity;
			  vv.excess += d;
			  v.excess-=d;
			  forward_edge.residual_capacity -= d;
			  forward_edge.rev_residual_capacity += d;
		  }
    }

    	bool flag2=true;

	do{
		flag2 = false;
        forall (v in g.nodes().filter(v.excess>0 && v!=source0 && v!=sink0 )) {
			flag2 = true;

			do {
				if(v.excess>0){
								int hh = INT_MAX;
			int v_0 = -1;
			int forward_edge = -1;
			int backward_edge = -1;
			for(vv in g.neighbors(v)) {
				edge e = g.get_edge(v,vv);
				int xxx=e.residual_capacity;
				if(vv.height<hh && xxx >0){
					v_0=vv;
					hh=vv.height;
					forward_edge = e;
				}
			}
			for(vv in g.nodes_to(v)) {
				edge rev = g.get_edge(vv,v);
				edge e = rev.reverse_edge;
				int xxx=e.rev_residual_capacity;
				if(vv.height<hh && xxx >0){
					v_0=vv;
					hh=vv.height;
					backward_edge = e;
					forward_edge = -1;
				}
			}

			if(v.height>hh && v_0!=-1){
        	    // int backward_edge = forward_edge.reverse_edge ;
				if(forward_edge!=-1){
					int fec = forward_edge.residual_capacity;
					int d=fec;
					if(v.excess<fec){
						d=v.excess;
					}
					v.excess -= d ;
        	    	v_0.excess += d ;
					forward_edge.residual_capacity -= d ;
        	    	forward_edge.rev_residual_capacity += d ;
				} else {
					int fec = backward_edge.rev_residual_capacity;
					int d=fec;
					if(v.excess<fec){
						d=v.excess;
					}
					v.excess -= d ;
        	    	v_0.excess += d ;
					backward_edge.rev_residual_capacity -= d ;
        	    	backward_edge.residual_capacity += d ;
				}

			}
			else if(v_0!=-1){
				v.height = hh + 1;
			}
				}
				cycle = cycle - 1;
			} while(cycle>0);

		
        }
    }while(flag2);  
}
Decremental(Graph g, int source1, int sink1, propEdge<int> residual_capacity,propEdge<int> rev_residual_capacity,propEdge<int> reverse_edge,propNode<int> excess, int cycle) {
    
    propNode<int> height2;
    g.attachNodeProperty(height2 = 0);
    sink1.height2 = g.num_nodes();

    forall(v in g.nodes()){
		int e1 = 0;
      	for(nbr in g.neighbors(v)){
        	edge e = g.get_edge(v,nbr);
          	e1=e1-e.rev_residual_capacity;
      	}
		for(src in g.nodes_to(v)){
			int rev = g.get_edge(src,v);
			int e = rev.reverse_edge;
			e1=e1+e.rev_residual_capacity;
		}
		v.excess = e1;
    }

	forall (v in g.nodes().filter(v==sink1)) {
		for(vv in g.nodes_to(v)){
			edge backward_edge = g.get_edge(vv, v) ;
			edge forward_edge = backward_edge.reverse_edge;
			int d = forward_edge.residual_capacity;
			v.excess += d;
			vv.excess-=d;
			forward_edge.residual_capacity -= d;
			forward_edge.rev_residual_capacity += d;
		}
    }
    


	bool flag3=true;

	do{
		  flag3 = false;
      forall (v in g.nodes().filter(v.excess<0 && v!=source1 && v!=sink1 )) {
			  flag3 = true;

			  do{
				if(v.excess<0){
								  int hh = INT_MAX;
			  int v_0 = -1;
			int inward_edge = -1;
			int outward_edge = -1;
			  for(vv in g.neighbors(v)) {
			  	edge e = g.get_edge(v,vv);
			  	int xxx=e.rev_residual_capacity;
			  	if(vv.height2<hh && xxx >0){
			  		v_0=vv;
			  		hh=vv.height2;
					outward_edge = e;
			  	}
			  }
			for(vv in g.nodes_to(v)) {
			  	edge rev = g.get_edge(vv,v);
				edge e = rev.reverse_edge;
			  	int xxx=e.residual_capacity;
			  	if(vv.height2<hh && xxx >0){
			  		v_0=vv;
			  		hh=vv.height2;
					inward_edge = e;
					outward_edge = -1;
			  	}
			  }

			  if(v.height2>hh && v_0!=-1){
				if(outward_edge!=-1){
					int d = outward_edge.rev_residual_capacity;
					int yy = (v.excess)*(-1);
			  		if(yy<d){
			  			d=yy;
			  		}
			  		v.excess += d ;
          			v_0.excess -= d ;
			  		outward_edge.rev_residual_capacity -= d ;
          			outward_edge.residual_capacity += d ;
				} else {
					int d = inward_edge.residual_capacity;
					int yy = (v.excess)*(-1);
			  		if(yy<d){
			  			d=yy;
			  		}
			  		v.excess += d ;
          			v_0.excess -= d ;
			  		inward_edge.residual_capacity -= d ;
          			inward_edge.rev_residual_capacity += d ;
				}

			  }
			  else if(v_0!=-1){
			  	v.height2 = hh + 1;
			  }
				}
				cycle = cycle - 1;
			  } while (cycle>0);
			  

          
      }
    }while(flag3); 

}