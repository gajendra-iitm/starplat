Incremental(Graph g, int source, int sink, propEdge<int> residual_capacity,propEdge<int> rev_residual_capacity,propEdge<int> reverse_edge,propNode<int>excess) {

    propNode<int> height;
    g.attachNodeProperty (height = 0) ;
    source.height = g.num_nodes();
    
	
	forall (v in g.nodes().filter(v==source)) {
		for(vv in g.neighbors(v)){
			edge forward_edge = g.get_edge(v, vv) ;
			int d = forward_edge.residual_capacity;
			vv.excess += d;
			v.excess-=d;
			forward_edge.residual_capacity -= d;
			forward_edge.rev_residual_capacity += d;
		}
    }
    
	bool flag2=true;

	do{
		flag2 = false;
        forall (v in g.nodes().filter(v.excess>0 && v!=source && v!=sink )) {
			flag2 = true;
			int hh = INT_MAX;
			int v_0 = -1;
			int forward_edge = -1;
			int backward_edge = -1;
			for(vv in g.neighbors(v)) {
				edge e = g.get_edge(v,vv);
				int xxx=e.residual_capacity;
				if(vv.height<hh && xxx >0){
					v_0=vv;
					hh=vv.height;
					forward_edge = e;
				}
			}
			for(vv in g.nodes_to(v)) {
				edge rev = g.get_edge(vv,v);
				edge e = rev.reverse_edge;
				int xxx=e.rev_residual_capacity;
				if(vv.height<hh && xxx >0){
					v_0=vv;
					hh=vv.height;
					backward_edge = e;
					forward_edge = -1;
				}
			}

			if(v.height>hh && v_0!=-1){
				if(forward_edge!=-1){
					int fec = forward_edge.residual_capacity;
					int d=fec;
					if(v.excess<fec){
						d=v.excess;
					}
					v.excess -= d ;
        	    	v_0.excess += d ;
					forward_edge.residual_capacity -= d ;
        	    	forward_edge.rev_residual_capacity += d ;
				} else {
					int fec = backward_edge.rev_residual_capacity;
					int d=fec;
					if(v.excess<fec){
						d=v.excess;
					}
					v.excess -= d ;
        	    	v_0.excess += d ;
					backward_edge.rev_residual_capacity -= d ;
        	    	backward_edge.residual_capacity += d ;
				}

			}
			else if(v_0!=-1){
				v.height = hh + 1;
			}
		
        }
    }while(flag2);    
}
Dynamic recalculate_max_flow(Graph g, updates<g> updateBatch, int batchSize, int source,int sink){
    propEdge<int>residual_capacity;
    propEdge<int> rev_residual_capacity;
    propEdge<int> reverse_edge;
    propNode<int> excess;
    
    Incremental(g,source, sink,residual_capacity,rev_residual_capacity,reverse_edge,excess);
 
}