Static staticMaxFlow (Graph g, int source, int sink, propEdge<int> residual_capacity,propEdge<int> rev_residual_capacity,propEdge<int> reverse_edge, propNode<int> excess,propEdge<int> parallel_edge,int kernel_cycle) {
    propNode<int> height;
    g.attachNodeProperty (height = 0) ;
    source.height = g.num_nodes();
	int V = g.num_nodes();
    g.attachNodeProperty(excess=0);
	forall(v in g.nodes()){
		for(dst in g.neighbors(v)){
			edge e1 = g.get_edge(v,dst);
			e1.residual_capacity = e1.weight;
			e1.rev_residual_capacity = 0;
			e1.parallel_edge = -1;
			for( pnbr in g.neighbors(dst)){
				edge p = g.get_edge(dst,pnbr);
				if(pnbr==v){
					e1.parallel_edge = p;
					e1.rev_residual_capacity = p.weight;
				}
			}
		}
		for(src in g.nodes_to(v)){
			edge rev = g.get_edge(src,v);
			for(vv in g.neighbors(src)){
				edge e = g.get_edge(src,vv);
				if(vv==v){
					rev.reverse_edge = e;
				}
			}	
			for( dst in g.neighbors(v) ){
				edge fe = g.get_edge(v,dst);
				if(dst==src){
					rev.reverse_edge = -1;
				}
			}
		}
	}
	    
	forall (v in g.nodes().filter(v==source)) {
      for(vv in g.neighbors(v)){
			  edge forward_edge = g.get_edge(v, vv) ;
			  int d = forward_edge.residual_capacity;
			  if(d>0){
				vv.excess += d;
			  	v.excess-= d;
			  	forward_edge.residual_capacity -= d;
			  	forward_edge.rev_residual_capacity += d;
			  	int p = forward_edge.parallel_edge;
			  	if(p !=-1){
					p.residual_capacity += d;
					p.rev_residual_capacity -= d;
			  	}
			  }

		  }

		for(vv in g.nodes_to(v)){
			  edge backward_edge = g.get_edge(vv, v) ;
			  int forward_edge = backward_edge.reverse_edge;
			  if(forward_edge!=-1) {
				int d = forward_edge.rev_residual_capacity;
			  	if(d>0) {
					vv.excess += d;
			  		v.excess-=d;
			  		forward_edge.residual_capacity -= d;
			  		forward_edge.rev_residual_capacity += d;
				}
			  }

		  }
    }
	bool flag1=true;
	do{
		flag1 = false;
        forall (v in g.nodes().filter(v.excess>0 && v!=source && v!=sink && v.height<V)) {
			flag1 = true;
			int cycle = kernel_cycle;
			do {
				if(v.excess>0 && v.height<V ){
					int hh = INT_MAX;
					int v_0 = -1;
					int forward_edge = -1;
					int backward_edge = -1;
					for(vv in g.neighbors(v)) {
						edge e = g.get_edge(v,vv);
						if(vv.height<hh && e.residual_capacity >0){
							v_0=vv;
							hh=vv.height;
							forward_edge = e;
						}
					}
					for(vv in g.nodes_to(v)) {
						edge rev = g.get_edge(vv,v);
						edge e = rev.reverse_edge;
						if(e!=-1){
							if(vv.height<hh && e.rev_residual_capacity >0){
								v_0=vv;
								hh=vv.height;
								backward_edge = e;
								forward_edge = -1;
							}
						}

					}

					if(v.height>hh && v_0!=-1){
						if(forward_edge!=-1){
							int fec = forward_edge.residual_capacity;
							int p = forward_edge.parallel_edge;
							int d=fec;
							if(v.excess<fec){
								d=v.excess;
							}
							v.excess -= d ;
        			    	v_0.excess += d ;
							forward_edge.residual_capacity -= d ;
        			    	forward_edge.rev_residual_capacity += d ;
							if(p!=-1){
								p.residual_capacity += d;
								p.rev_residual_capacity -= d;

							}
						} else {
							int fec = backward_edge.rev_residual_capacity;
							int d=fec;
							if(v.excess<fec){
								d=v.excess;
							}
							v.excess -= d ;
        			    	v_0.excess += d ;
							backward_edge.rev_residual_capacity -= d ;
        			    	backward_edge.residual_capacity += d ;
						}
					}

				}
				cycle = cycle - 1;
			} while(cycle>0);
			
        }
    }while(flag1); 

}
