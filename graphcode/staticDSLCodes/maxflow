function maxflow(Graph g, int s, int t){
// Assumption DAG and u -> v and v->u simultaneously not present -(Standard Assumption)
// Graph present in such a way that if u->v is in E, then CSR of u and v contain each other 
//with w(u,v) = cap and w(v,u) = -1;
    propEdge<int>cf;
    propNode<int>h;
    propNode<int>e;
    int ExcessTotal = 0;
    int N = g.num_nodes();
    // initialising 
    forall(v in g.nodes()){
        if(v==s){
            v.h = N;
            v.e = 0;
        }
        else{
            v.h = 0;
            v.e = 0;
        }
        
        for(nbr in g.neighbors(v)){
            edge e1 = g.get_edge(v,nbr);
            e1.cf = e1.weight;
            if(e1.cf == -1){
                 e1.cf_backward = 0;
            }
        }
    }
    int v = 0;
    do{
        if(v==s){
            v.h = N;
            v.e = 0;
        }
        else{
            v.h = 0;
            v.e = 0;
        }
        
        for(nbr in g.neighbors(v)){
            edge e1 = g.get_edge(v,nbr);
            e1.cf = e1.weight;
            if(e1.cf == -1){
                 e1.cf_backward = 0;
            }
        }
        v=v+1;
    }while(v<N);
    // forall(v in g.nodes().filter(v==s)){
    //     for(nbr in g.neighbors(v)){
    //         edge e1 = g.get_edge(v,nbr);
    //         int d =  e1.cf;
    //         if(d==0){
    //             continue;
    //         }
    //         e1.cf_forward = 0;
    //         e1.cf_backward = d;
    //         nbr.e = d;
    //         ExcessTotal = ExcessTotal+d;
    //     }
    // }
    bool finished = false;
    do {
        forall(v in g.nodes()){
            int cycle = 100;
            do {
                int e1 = v.e;
                int h1 = INF;
                int v1 =-1;
                for(nbr in g.neighbors(v)){
                    int h2 = nbr.h;
                    if(h2<h1){
                        v1 = nbr;
                        h1 = h2;
                    }
                }
                if(v.h > h1){
                    edge ee = g.get_edge(v,v1);
                    int d = -1;
                    if(e1 < ee.cf_forward){
                        d = e1;
                    } else {
                        d = ee.cf_forward;
                    }
                    ee.cf_backward-=d;
                }
            } while(cycle>0);
        }
    } while(finished);
    return 0;
}
