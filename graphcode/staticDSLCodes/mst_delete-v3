// function recolor(propEdge<bool>isCovered,Graph g, propNode<int> parent, propEdge<int> destination){
//     forall( v in g.nodes()){
//         if(true){
// v.parent = v;
//         }
        
//     }
//     propNode<bool> modified;
//     g.attachNodeProperty(modified = True);
//     bool rfinish1 = false;
//     fixedPoint until(rfinish1 :!modified){

//         // update Leader
//         forall(v in g.nodes()){
//             int mycolor = v.parent;
//             int newcomponent = mycolor;
//             forall( dst in g.neighbors(v)){
//                 edge e = g.get_edge(v,dst);
//                 if(e.destination!=-1){
//                     int othercolor = dst.parent;
//                     if(othercolor<newcomponent){
//                         newcomponent=othercolor;
//                     }  
//                 }
//             }
//             if(mycolor>newcomponent){
//                 v.parent = newcomponent;
//                 rfinish1 = false;
//             }
//             forall(dst in g.neighbors(v)){
//                 edge e = g.get_edge(v,dst);
//                 if(e.destination!=-1){
//                     if(dst.parent>newcomponent){
//                         dst.parent = newcomponent;
//                         rfinish1 = false;
//                     }
//                 }
//             }
//         }
//         // settle while
//         bool rfinish2 = false;
//         fixedPoint until(rfinish2 :!modified){
//             forall(v in g.nodes()){
//                 int par = v.parent;
//                 if(par.parent!=par){
//                     v.parent = par.parent;
//                     rfinish2 = false;
//                 }
//             }
//         }    
//     }
// }



function total_code(Graph g, updates<g> batch){
    // propNode<int> parent;
    // propEdge<int> destination;
    // propEdge<bool>isMST;
    // g.attachNodeProperty(parent=-1);
    // forall(v in g.nodes()){
    //     if(true){
    //         v.parent = v;
    //     }
    //     forall(dst in g.neighbors(v)){
    //         edge e = g.get_edge(v,dst);
    //         e.destination = dst;
    //         e.isMST = false;
    //     }
    // }
    
    // propNode<int> minedge;
    // propNode<int> minweight;
    

    // g.attachNodeProperty(minedge = -1);
    // g.attachNodeProperty(minweight = -1 );
    




    // bool hasComponent = true;
    // propNode<bool> modified;
    // bool finished =False;
        

    // do{
    //     hasComponent = false;
    //     g.attachNodeProperty(minedge = -1);
    //     g.attachNodeProperty(minweight = -1);

    //     // BK2
    //     forall(src in g.nodes())
    //     {
    //         forall(dst in g.neighbors(src))
    //         {
    //             if(dst!=-1){
    //                 edge e = g.get_edge(src, dst);
    //                 if(e.isCovered == false) {
    //                 int x = src.minweight;
    //                 if (x==-1|| x> e.weight){
    //                     x = e.weight;
    //                 }
    //                 src.minweight = x;
    //                 src.minedge = e;
    //                 }   
    //             }
    //         }
    //     }

    //     // BK3
    //     g.attachNodeProperty(modified = True);
    //     fixedPoint until(finished :!modified){
    //         forall(v in g.nodes().filter(modified==True)){
    //             int par = v.parent;
    //             if(v.minweight<par.minweight){
    //                 par.minweight = v.minweight;
    //                 par.minedge = v.minedge;
    //                 finished = False;
    //             }
    //         }
    //     }

    //     forall(v in g.nodes().filter(parent==v)){
    //         int e = v.minedge;
    //         if(e!=-1){
    //             int dst1 = e.destination;
    //             int pardst1 = e.parent;
    //             int epar = pardst1.minedge;
    //             if(epar!=-1){
    //                 int dstdst = epar.destination;
    //                 if(dstdst == v && pardst1 < v){
    //                     pardst1.minedge = -1;
    //                 }

    //             }
                 
    //         }
    //     }
    //     forall(v in g.nodes().filter(parent == v)){
    //         int e = v.minedge;
    //         if(e!=-1){
    //             e.isCovered = True;
    //             hasComponent = True;
    //             int dst = e.destination;
    //             v.parent = dst;
    //         }
    //     }

    //     finished = False;        
    //     fixedPoint until(finished: !modified){
    //         forall(v in g.nodes()){
    //             int par = v.parent;
    //             if(par.parent!=par){
    //                 finished = False;
    //                 v.parent = par.parent;
    //             }
    //         }
    //     }

    // }while(hasComponent);
    




















    // forall(ups in batch){
    //     int src = ups.source;
    //     int dst = ups.destination;
    //     edge e = g.get_edge(src,dst);
    //     e.destination = -1;
    //     e.isMST = false;
    // }
    // recolor(isCovered,g,  parent,destination);
    // mst_boruvkas_add_edges(g,isCovered, parent,destination);
    return 0;
}

