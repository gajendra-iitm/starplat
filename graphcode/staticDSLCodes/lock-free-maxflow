function do_max_flow (Graph g, int source, int sink) {

    propNode<int> height;
    g.attachNodeProperty (height = 0) ;
    source.height = g.num_nodes();
    
    propNode<int> excess;
    g.attachNodeProperty (excess = 0) ;
	
	propEdge<int> residual_capacity;
	forall(v in g.nodes()){
		for(dst in g.neighbors(v)){
			edge e = g.get_edge(v,dst);
			e.residual_capacity = e.weight;
		}
	}
	
	forall(v in g.neighbors(source)){
		edge forward_edge = g.get_edge(source, v) ;
		edge backward_edge = g.get_edge(v, source) ;
		int d = forward_edge.residual_capacity;
		v.excess += d;
		source.excess-=d;
		forward_edge.residual_capacity -= d;
		backward_edge.residual_capacity += d;
	}
    
	bool flag=true;

	do{
		flag = false;
        forall (v in g.nodes().filter(v.excess>0 && v!=source && v!=sink )) {
			flag = true;
			int hh = INT_MAX;
			int v_0 = -1;
			for(vv in g.neighbors(v)) {
				edge e = g.get_edge(v,vv);
				int xxx=e.residual_capacity;
				if(vv.height<hh && xxx >0){
					v_0=vv;
					hh=vv.height;
				}
			}

			if(v.height>hh && v_0!=-1){
        	    edge forward_edge = g.get_edge (v, v_0) ;
        	    edge backward_edge = g.get_edge (v_0, v) ;
				int fec = forward_edge.residual_capacity;
				int d=fec;
				if(v.excess<fec){
					d=v.excess;
				}
				v.excess -= d ;
        	    v_0.excess += d ;
				forward_edge.residual_capacity -= d ;
        	    backward_edge.residual_capacity += d ;
			}
			else if(lv!=-1){
				v.height = hh + 1;
			}
        }
    }while(flag);    

}
