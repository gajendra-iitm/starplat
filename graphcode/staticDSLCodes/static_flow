function staticMaxFlow (Graph g, int source2, int sink2,int kernel ) {
    propEdge<int> residual_capacity;
    propEdge<int> rev_residual_capacity;
    propEdge<int> reverse_edge; 
    propNode<int> excess;
    g.attachNodeProperty(excess = 0);
    
    propNode<int> height;
    g.attachNodeProperty (height = 0) ;
    source2.height = g.num_nodes();

	forall(v in g.nodes()){
		for(dst in g.neighbors(v)){
			edge e1 = g.get_edge(v,dst);
			e1.residual_capacity = e1.weight;
			e1.rev_residual_capacity = 0;
		}
		for(src in g.nodes_to(v)){
			edge rev = g.get_edge(src,v);
			for(vv in g.neighbors(src)){
				edge e = g.get_edge(src,vv);
				if(vv==v){
					rev.reverse_edge = e;
				}
			}
		}
	}
	forall (v in g.nodes().filter(v==source2)) {
      for(vv in g.neighbors(v)){
			  edge forward_edge = g.get_edge(v, vv) ;
			  int d = forward_edge.residual_capacity;
			  vv.excess += d;
			  v.excess-=d;
			  forward_edge.residual_capacity -= d;
			  forward_edge.rev_residual_capacity += d;
		  }
    }   
    bool flag1=true;
	int cnt = 0;
    do{
		cnt++;
		
        flag1 = false;
        forall (v in g.nodes().filter(v.excess>0 && v!=source2 && v!=sink2 )) {
            flag1 = true;
            do {
                int hh = INT_MAX;
			    int v_0 = -1;
			    int forward_edge = -1;
			    int backward_edge = -1;
                for(vv in g.neighbors(v)) {
				    edge e = g.get_edge(v,vv);
				    int xxx=e.residual_capacity;
				    if(vv.height<hh && xxx >0){
				    	v_0=vv;
				    	hh=vv.height;
				    	forward_edge = e;
				    }
			    }
                for(vv in g.nodes_to(v)) {
				    edge rev = g.get_edge(vv,v);
				    edge e = rev.reverse_edge;
				    int xxx=e.rev_residual_capacity;
				    if(vv.height<hh && xxx >0){
				    	v_0=vv;
				    	hh=vv.height;
				    	backward_edge = e;
				    	forward_edge = -1;
				    }
			    }
                if(v.height>hh && v_0!=-1){
				    if(forward_edge!=-1){
				    	int fec = forward_edge.residual_capacity;
				    	int d=fec;
				    	if(v.excess<fec){
				    		d=v.excess;
				    	}
				    	v.excess -= d ;
        	        	v_0.excess += d ;
				    	forward_edge.residual_capacity -= d ;
        	        	forward_edge.rev_residual_capacity += d ;
				    } else {
				    	int fec = backward_edge.rev_residual_capacity;
				    	int d=fec;
				    	if(v.excess<fec){
				    		d=v.excess;
				    	}
				    	v.excess -= d ;
        	        	v_0.excess += d ;
				    	backward_edge.rev_residual_capacity -= d ;
        	        	backward_edge.residual_capacity += d ;
				    }
			    } else if(v_0!=-1){
				    v.height = hh + 1;
			    }
                kernel = kernel - 1;
            }while(kernel>0 && v.excess>0) ;
			
        }
		
    } while(flag1);
}